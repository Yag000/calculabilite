\section{Notion de calculabilité}


\begin{definition}[Langage semi-décidable]
	Un langage $L \subseteq \mots$ est \textbf{semi-décidable} s'il existe une machine de Turing $M$ \tlq
	$$ \forall w \in \mots, w \in L \iff M(w) = 1 $$
\end{definition}

\begin{definition}[Langage décidable]
	Un langage $L \subseteq \mots$ est \textbf{décidable} s'il existe une machine de Turing $M$ \tlq
	$$ \forall w \in \mots, w \in L \implies M(w) = 1 \quad \text{et} \quad w \notin L \implies M(w) = 0 $$
	et $M$ s'arrête pour tout $w$.
\end{definition}

\begin{prop}
	Tout langage décidable est semi-décidable.
\end{prop}

\begin{proof}
	Il suffit de monter que si $M$ est une machine de Turing qui décide $L$, alors $M(w) = 1 \iff w \in L$.
	\begin{itemize}
		\item $w \in L \implies M(w) = 1$ est vrai par définition.
		\item $M(w) = 1 \implies w \in L$ peut être montrée par contraposée. Si $w \notin L$, alors $M(w) = 0$ car $M$ décide $L$ et donc $M(w) \neq 1$.
	\end{itemize}
\end{proof}

\begin{definition}[Fonction calculable]
	$f : \mots \to \mots$ est calculable si $\exists M$ \tq $\forall w \in \mots, M$ s'arrête sur $w$ avec $f(w)$ sur le ruban.
\end{definition}

\begin{lemma}
	La composition de deux fonctions calculables est calculable
\end{lemma}

\begin{lemma}
	La fonction $succ : \mots \to \mots$ est calculable.
\end{lemma}

\begin{prop}
	$L$ est décidable $\iff$ sa fonction caractéristique est calculable.
\end{prop}

\begin{definition}
	$f : \mots \to \mots$ énumère $L \subseteq \mots$ si $\im f = L$ \ie $\forall w \in L \iff \exists w' \in \mots, f (w') = w$.
\end{definition}

\begin{prop}
	$L$ est récursivement énumerable $\iff$ $L$ est semi-décidable.
\end{prop}

\begin{proof}
	Vue en TD.
\end{proof}


On peut encoder toute machine de Turing par un nombre, qui est appété le nombre de Gödel et noté : $\encode M \in \mots$.

\begin{definition}[Énumération des fonctions calculables] \label{def:enum}
	$\forall n \in \N, \ \phi_n$ est la fonction calculée par la $n$-ième machine de Turing.
	$$\phi_{\encode M} (w) = M (w)$$
\end{definition}


\begin{lemma}[Machines universelles]\label{lem:univ}
	Il existe une machine universelle $U$, \ie, $$\forall M,w, \  U (\encode {M,w}) = M (w)$$
	ou de manière equivalente
	$$\exists u, \forall n,w, \ \phi_n(w) = \phi_u(\encode {n,w})$$
\end{lemma}

\begin{definition}[eval]
	On note $eval(\encode M, w, n)$ la machine que simule l'exécution de $M$ sur $w$ en au plus $n$ étapes.
\end{definition}

\begin{prop}[Admis]
	$eval$ est décidable.
\end{prop}

\begin{prop}
	$L$ est décidable $\iff$ $L$ est semi-décidable \emph{et} $L^c$ est semi-décidable
\end{prop}

\begin{proof}
	\begin{itemize}
		\item \bimpLR \ triviale
		\item \bimpRL \\
		      On peut exécuter en parallèle des deux machines. Elle s'arrête forcement car on a bien que $\forall w, w \in L \lor w \notin L$.
	\end{itemize}
	Ce théorème et sa preuve détaillée correspondent à ceux présentés dans \cite[Theorem~4.22]{sipser}.
\end{proof}


\begin{prop}
	$L$ décidable $\iff \exists L_d \text{ décidable}, L = \setdef {w \in \mots} {\exists w' \in \mots, \encode{w,w'} \in L_d}$
\end{prop}


\begin{proof}
	$w \in L \iff \exists t, eval(\encode {M_L}, w, k) = 1$

	Alors on pose $L_d = \setdef {\encode{w, k}} {eval(\encode {M_L}, w,k) = 1}$.
	$L_d$ est décidable et on a l'équivalence par construction.
\end{proof}


\subsection{Quelques problèmes}

Quelques problèmes décidables en rapport aux automates :

\begin{itemize}
	\item $\text{ACCEPT}_A = \setdef {<A,w>} {A \text { est un automate qui accepte } w}$.
	      Dire que c'est problème est décidable revient a dire que $\exists$ un interpréteur d'automates en Machine de Turing.
	\item $\text{EQUIV}_A = \setdef {<A,A'>} {A \text { et } A' \text{ acceptent le meme langage}}$.
	\item $\text{EXISTS}_A = $ Il existe un mot reconnu.
	\item $\text{INFINITE}_A = $ le langage reconnu par $A$ est infini.
\end{itemize}

Cependant, ces problèmes étendus aux automates a piles, ne restent pas tous décidable.
$\text{ACCEPT}_{A_p}$ et $\text{INFINITE}_{A_p}$ restent décidables mais pas $\text{EQUIV}_{A_p}$.

\begin{definition}[Problème de l'arrêt]
	Le problème de l'arrêt est définit comme suit $HALT = \setdef {\encode{M,w}} {M \text{ s'arrête sur } w}$.
\end{definition}

\begin{proof}
	Admisse.
\end{proof}

\begin{prop}
	$HALT$ est semi-décidable.
\end{prop}

\begin{proof}
	Il suffit d'écrire un programme "impératif" :

	Entrée : $\encode {M,w}$

	Code:
	u(M,w);
	return 1;

\end{proof}

\begin{prop}
	HALT est indécidable.
\end{prop}

\begin{proof}
	Supposons par l'absurde que HALT est décidable. Alors il existe un entier $n$ \tq $\phi_n$ décide HALT, c'est-à-dire
	$ \phi_n(\encode {M, w} ) = 1 \iff \phi_n(w) \neq \bot $ et vaut $0$ sinon.

	Soit $n'$ le code de la fonction qui sur $w$ vaut 1 si $\phi_n (w,w) = 0 $ et n'est pas définie sinon. Alors
	\begin{eqnarray*}
		\phi_{n'}(n') = 1 & \text{si} & \phi_n(n',n') = 0\\
		&\text{\ie}& \phi_{n'}(n') \text{ ne s'arrête pas} \\
		&\text{\ie}& \phi_{n'}(n') = \bot\\\\
		\phi_{n'}(n') = \bot & \text{si} & \phi_n(n',n') = 1\\
		&\text{\ie}& \phi_{n'}(n') \neq \bot \quad \contradict
	\end{eqnarray*}
\end{proof}

\begin{exemple}
	Le Problème de Correspondance de Post (PCP) est indécidable. Le détail peut être consulté dans \cite[Chapter~5.2]{sipser}
\end{exemple}
