\usepackage{base-yago/base-yago}



%% Turing Machines

\newcommand{\encode}[1]{\left\langle#1\right\rangle}

%% Basic automata theory

%%%% Basic definitions

\newcommand{\alphabet}{\Sigma}

\newcommand{\mot}{w}

\newcommand{\decomp}[2] {
	#1_1 #1_2 \ldots #1_{#2}
}

\newcommand{\motDecomp}[2] {
	#1 = \decomp{#1}{#2}
}

\newcommand{\motvide}{\varepsilon}
\newcommand{\len}[1]{|#1|}


\newcommand{\kleenestar}{*}
\newcommand{\kleene}[1]{#1^{\kleenestar}}
\newcommand{\mots}{\kleene{\alphabet}}

%%%% Languages

\newcommand{\lang}[1]{\mathcal{L}\left(#1\right)}
\newcommand{\langstar}{\kleene{\lang}}


\newcommand{\leqm}{\leq_m}
\newcommand{\equivm}{\equiv_m}


\newcommand{\leqt}{\leq_T}
\newcommand{\equivt}{\equiv_T}

\newcommand{\fmots}[1]{#1 : \mots \to \mots}

\newcommand{\halt}{\text{ HALT }}

\newcommand{\universal}[2]{\mathcal U \left(\encode{#1,#2}\right)}

%%%% Regex

\newcommand{\eratsym}{ERat}
\newcommand{\erat}{\text{\eratsym}}

%% ocaml

\newcommand{\letin}[2]{\textbf{let } #1 = #2 \textbf{ in }}
\newcommand{\fun}[2]{\textbf{fun } #1 \rightarrow #2 }


%% General stuff

\newcommand{\reason}[1]{\quad\left(\textit{#1}\right)}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
		\node[shape=circle,draw,inner sep=2pt] (char) {#1};}}

\newcommand{\syntaxHeader}[3]{#1 &::=& #2 &\quad\text{#3}\\}
\newcommand{\syntaxExtension}[1]{\syntaxHeader{#1}{\cdots}{}}
\newcommand{\syntax}[2]{&|&#1&\quad\text{#2}\\}

\newenvironment{syntaxdef} {\begin{mathpar} \begin{array}{lcll}} {\end{array} \end{mathpar}}


\renewcommand{\phi}{\varphi}
\renewcommand{\epsilon}{\varepsilon}

\newcommand{\bimpRL}{\fbox{$\Leftarrow$}}
\newcommand{\bimpLR}{\fbox{$\Rightarrow$}}

\newcommand{\ra}{\rightarrow}

\newenvironment{proofI}[1][\proofname]{%
	\begin{proof}[#1]$ $\par\nobreak\ignorespaces
		}{%
	\end{proof}
}
